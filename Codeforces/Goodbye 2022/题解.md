# Codeforces Goodbye 2022解题记录
链接： [Good Bye 2022: 2023 is NEAR](https://codeforces.com/contest/1770)

## A. [Koxia and Whiteboards](https://codeforces.com/contest/1770/problem/A)
### 题意：
给定两个正整数数组$a_1,a_2,...a_n$和$b_1,b_2,...b_m$，对其进行$m$次操作，第$i$次用$b_i$来替换数组$a$中的某一个数，求$m$次操作后数组各项之和最大是多少？

### 思路：
&nbsp;&nbsp;&nbsp;&nbsp;显然每次操作最优策略是替换当前数组中最小的数，这样$m$次操作均采用这样的策略后最后总和最大。

&nbsp;&nbsp;&nbsp;&nbsp;每次操作前需要对数组$a$排序，然后将$a$的第一个数替换，时间复杂度为$O(nlogn)$。所以总复杂度为$O(mnlogn)$，而$n, m \leq 100$, 足够通过。

&nbsp;&nbsp;&nbsp;&nbsp; 官方题解中给出了更优的方案。将数组$a$和$b$放在一起排序取后面$n$个数，但要注意$b_m一定要取到$。时间复杂度为$O((n + m)log(n + m))$。

### 代码：
```C++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll t, n, m;
ll a[215], b;

void solve() {
	cin >> n >> m;
	ll s = 0;
//方案一： 暴力    
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
		s += a[i];
	}
	
	for (int i = 1; i <= m; ++i) {
		sort(a + 1, a + n + 1);    
		cin >> b;
		s += b - a[1];
		a[1] = b;		
	}
/*
方案二： 小技巧
	for (int i = 1; i <= n + m; ++i) {
		cin >> a[i];
	}
	s = a[n + m];
    sort(a + 1, a + n + m);
    for (int i = m + 1; i < m + n; ++i)
        s += a[i];
*/
	cout << s << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> t;
	while (t--) {
		solve();
	}
	
	return 0;
}


```